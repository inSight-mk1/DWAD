# DWAD系统架构设计文档

## 1. 总体架构

DWAD系统采用分层架构设计，包括数据层、服务层、业务层和表现层。

### 1.1 架构图
```
┌─────────────────────────────────────────────────────────┐
│                     表现层 (Presentation Layer)           │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │ Flask仪表盘     │  │ Streamlit应用   │  │   CLI工具     │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────┐
│                     业务层 (Business Layer)              │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  股池管理模块     │  │  指数计算模块     │  │  分析比较模块  │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────┐
│                     服务层 (Service Layer)               │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  数据获取服务     │  │  数据处理服务     │  │  缓存服务     │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────┐
│                     数据层 (Data Layer)                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  行情数据存储     │  │  股池配置存储     │  │  指数数据存储  │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────┐
│                   外部接口 (External APIs)               │
│                   ┌─────────────────┐                   │
│                   │   掘金量化API     │                   │
│                   └─────────────────┘                   │
└─────────────────────────────────────────────────────────┘
```

## 2. 核心模块设计

### 2.1 数据获取模块 (data_fetcher)

#### 2.1.1 核心类设计
```python
class DataFetcher:
    """数据获取基类"""
    def get_stock_info(self, stock_name: str) -> StockInfo
    def get_historical_data(self, symbol: str, start_date: str, end_date: str) -> DataFrame
    def get_realtime_data(self, symbols: List[str]) -> DataFrame

class GoldMinerFetcher(DataFetcher):
    """掘金平台数据获取实现"""
    def __init__(self, token: str)
    def init_api(self) -> bool
    def fetch_stock_data(self, symbol: str, start_date: str, end_date: str) -> DataFrame

class RealtimePriceFetcher:
    """实时价格获取器"""
    def __init__(self)
    def get_realtime_prices(self, symbols: List[str]) -> Dict[str, float]
```

#### 2.1.2 数据模型
```python
@dataclass
class StockInfo:
    symbol: str          # 股票代码
    name: str           # 股票名称
    market: str         # 市场代码
    sector: str         # 行业
    market_cap: float   # 市值

@dataclass
class MarketData:
    symbol: str
    date: datetime
    open_price: float
    close_price: float
    high_price: float
    low_price: float
    volume: int
    turnover: float
    market_cap: float
```

### 2.2 数据存储模块 (data_storage)

#### 2.2.1 存储方案评估

**方案A：文件存储 (推荐)**
- **优势**：简单易维护，无需额外依赖，适合中小规模数据
- **实现**：使用Parquet格式存储，支持高效压缩和快速读取
- **结构**：
  ```
  data/
  ├── stocks/          # 个股数据
  │   ├── 000001.SZ.parquet
  │   └── ...
  ├── indices/         # 指数数据
  │   ├── concept_tech.parquet
  │   └── ...
  └── metadata/        # 元数据
      ├── stock_info.json
      └── update_log.json
  ```

**方案B：数据库存储**
- **优势**：支持复杂查询，数据一致性好
- **实现**：SQLite (轻量级) 或 PostgreSQL (高性能)
- **表结构**：
  ```sql
  -- 股票信息表
  CREATE TABLE stock_info (
      symbol VARCHAR(20) PRIMARY KEY,
      name VARCHAR(100),
      market VARCHAR(10),
      sector VARCHAR(50),
      created_at TIMESTAMP
  );

  -- 行情数据表
  CREATE TABLE market_data (
      id SERIAL PRIMARY KEY,
      symbol VARCHAR(20),
      date DATE,
      open_price DECIMAL(10,3),
      close_price DECIMAL(10,3),
      high_price DECIMAL(10,3),
      low_price DECIMAL(10,3),
      volume BIGINT,
      turnover DECIMAL(15,2),
      market_cap DECIMAL(15,2),
      UNIQUE(symbol, date)
  );
  ```

#### 2.2.2 数据访问层
```python
class DataStorage:
    """数据存储抽象接口"""
    def save_market_data(self, data: List[MarketData]) -> bool
    def get_market_data(self, symbol: str, start_date: str, end_date: str) -> DataFrame
    def get_stock_list(self) -> List[StockInfo]
    def update_stock_info(self, stock_info: StockInfo) -> bool

class ParquetStorage(DataStorage):
    """Parquet文件存储实现"""
    def __init__(self, data_dir: str)

class DatabaseStorage(DataStorage):
    """数据库存储实现"""
    def __init__(self, connection_string: str)
```

### 2.3 股池管理模块 (pool_manager)

#### 2.3.1 股池配置格式
```json
{
  "pools": {
    "大概念股池": {
      "机器人概念": ["埃斯顿", "拓斯达", "汇川技术"],
      "电池概念": ["宁德时代", "比亚迪", "国轩高科"],
      "半导体概念": ["中芯国际", "韦尔股份", "兆易创新"]
    },
    "重点关注股池": {
      "AI概念": ["科大讯飞", "海康威视", "大华股份"]
    },
    "持仓股池": {
      "当前持仓": ["贵州茅台", "五粮液", "腾讯控股"]
    }
  }
}
```

#### 2.3.2 股池管理类
```python
class StockPool:
    def __init__(self, name: str, concept: str, stocks: List[str])

class PoolManager:
    def load_pools(self, config_file: str) -> Dict[str, Dict[str, StockPool]]
    def save_pools(self, pools: Dict, config_file: str) -> bool
    def add_stock_to_pool(self, pool_name: str, concept: str, stock: str) -> bool
    def get_pool_stocks(self, pool_name: str, concept: str) -> List[str]
    def validate_pool_config(self) -> List[str]  # 返回验证错误列表
```

### 2.4 指数计算模块 (index_calculator)

#### 2.4.1 指数计算类
```python
class IndexCalculator:
    def __init__(self, data_storage: DataStorage)

    def calculate_market_cap_weighted_index(self,
                                          stocks: List[str],
                                          start_date: str,
                                          end_date: str,
                                          base_date: str = None,
                                          base_value: float = 100.0) -> DataFrame

    def calculate_price_average_index(self,
                                    stocks: List[str],
                                    start_date: str,
                                    end_date: str,
                                    base_date: str = None,
                                    base_value: float = 100.0) -> DataFrame

    def calculate_concept_indices(self, pool_config: Dict) -> Dict[str, DataFrame]
```

#### 2.4.2 指数计算逻辑
- **市值加权指数**：`Index_t = (Σ(Price_i,t × Shares_i)) / (Σ(Price_i,base × Shares_i)) × base_value`
- **平均股价指数**：`Index_t = (Σ(Price_i,t) / N) / (Σ(Price_i,base) / N) × base_value`

### 2.5 分析比较模块 (analysis)

#### 2.5.1 分析计算类
```python
class ConceptAnalyzer:
    def __init__(self, index_calculator: IndexCalculator)

    def compare_concepts_within_pool(self,
                                   pool_name: str,
                                   time_period: Tuple[str, str]) -> DataFrame

    def compare_concept_across_pools(self,
                                   concept_name: str,
                                   time_period: Tuple[str, str]) -> DataFrame

    def calculate_performance_metrics(self, index_data: DataFrame) -> Dict:
        # 收益率、波动率、夏普比率、最大回撤等

    def rank_concepts(self,
                     performance_data: Dict,
                     ranking_metric: str = "total_return") -> List[Tuple[str, float]]
```

### 2.6 可视化模块 (visualization)

#### 2.6.1 图表生成类
```python
class ChartGenerator:
    def __init__(self, theme: str = "default")

    def plot_index_comparison(self,
                            indices_data: Dict[str, DataFrame],
                            title: str = "概念指数对比") -> Figure

    def plot_heatmap(self,
                   performance_matrix: DataFrame,
                   title: str = "概念强弱热力图") -> Figure

    def plot_performance_bar(self,
                           ranking_data: List[Tuple[str, float]],
                           metric_name: str) -> Figure

    def export_chart(self, figure: Figure, file_path: str, format: str = "png") -> bool
```

## 3. 数据流设计

### 3.1 初始化流程
```
1. 加载股池配置 → 2. 验证股票代码 → 3. 批量获取历史数据 → 4. 存储到本地 → 5. 计算初始指数
```

### 3.2 日常更新流程
```
1. 检查最新数据日期 → 2. 获取增量数据 → 3. 数据清洗验证 → 4. 更新存储 → 5. 重新计算指数
```

### 3.3 分析查询流程
```
1. 用户选择分析参数 → 2. 加载相关数据 → 3. 执行分析计算 → 4. 生成图表 → 5. 展示结果
```

## 4. 技术选型建议

### 4.1 核心技术栈
- **编程语言**：Python 3.12+
- **数据处理**：pandas, numpy
- **数据存储**：Parquet (pyarrow)
- **可视化**：plotly, matplotlib
- **Web框架**：Flask (仪表盘服务) + Streamlit (交互式应用)
- **量化平台**：掘金SDK (gm)
- **配置管理**：YAML
- **日志系统**：loguru

### 4.2 第三方库推荐
```python
# requirements.txt
pandas>=1.5.0
numpy>=1.21.0
pyarrow>=10.0.0
plotly>=5.0.0
streamlit>=1.20.0
flask>=3.0.0
pyyaml>=6.0
loguru>=0.6.0
gm  # 掘金SDK
```

### 4.3 Linux远程终端支持

掘金终端仅支持Windows，Linux环境需通过远程连接方式使用：

```python
from gm.api import set_token, set_serv_addr

# Linux环境：先设置远程终端地址
set_serv_addr("192.168.1.100:7001")  # Windows终端IP:端口

# 然后设置token
set_token("your_token")
```

详见 [掘金API知识文档](掘金API知识文档.md)

## 5. 部署架构

### 5.1 本地部署
```
DWAD/
├── config/              # 配置文件
├── data/               # 数据存储
├── logs/               # 日志文件
├── src/dwad/           # 源代码
├── scripts/            # 脚本工具
├── docs/               # 文档
├── dashboard_server.py # Flask仪表盘 (端口8818)
└── web_app.py          # Streamlit应用
```

### 5.2 启动服务
```bash
# Flask仪表盘
python dashboard_server.py

# Streamlit应用
streamlit run web_app.py
```

### 5.3 性能优化策略
- 数据分片存储，按月份或年份分割
- 使用缓存机制，避免重复计算
- 异步数据获取，提高并发性能
- 增量计算，只处理新增数据

## 6. 安全和错误处理

### 6.1 错误处理策略
- API调用失败重试机制
- 数据缺失的填充策略
- 异常日志记录和告警
- 数据备份和恢复机制

### 6.2 安全考虑
- API密钥安全存储
- 数据访问权限控制
- 输入参数验证
- 防止数据篡改